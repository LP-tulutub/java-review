package com.java.review.database;

public class DatabaseTest {
}

/**
 * 1.关系型数据库与非关系型数据库？
 * 2.请列出Java常见的开源数据连接池，并对参数做出简单的说明？
 *  DBCP：DBCP是一个依赖Jakarta commons-pool对象池机制的数据库连接池
 *  c3p0：c3p0是一个开放源代码的JDBC连接池
 *  Druid：淘宝和支付宝专用数据库连接池，还包含一个ProxyDriver，一系列内置的JDBC组件库
 * 3.储蓄所有多个储户，储户在多个储户所存取款，储蓄所与储户之间是几对几？
 *  多对多
 * 4.视图是一个“虚表”，视图的构造基于什么？
 *  基本表或视图
 * 5.设有关系R(A,B,C,D)及其上的函数相关性集合F={B→A,BC→D},那么关系R最高是什么？
 *  第一范式的
 *  F分开后就是第三范式的
 *  第一范式：保证每列的原子性
 *  第二范式：保证一张表只描述一件事情
 *  第三范式：保证每列都和主键直接相关
 * 6.什么是DAO模式？
 *  DAO（DataAccess Object）是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露数据库实现细节的前提下提供了各种数据操作
 * 7.数据库MySQL，Oracle，SqlServer分页时用的语句？
 *  limit关键字
 * 8.Oracle完成分页功能的三层子查询语句及其含义？
 *  select * from (select name,age r from (select * from A) t where age < 10) where r >5
 * 9.问SQL怎么优化执行效率更高？
 *  SQL优化的原则是：将一次操作需要读取的BLOCK数减到最低,即在最短的时间达到最大的数据吞吐量
 *      检查不良的SQL，考虑其写法是否还有可优化内容
 *      检查子查询，考虑SQL子查询是否可以用简单连接的方式进行重新书写
 *      检查优化索引的使用
 *      考虑数据库的优化器
 *      避免出现SELECT * FROM table 语句，要明确查出的字段
 *      在一个SQL语句中，如果一个where条件过滤的数据库记录越多，定位越准确，则该where条件越应该前移
 *      查询时尽可能使用索引覆盖
 *      在判断有无符合条件的记录时建议不要用SELECT COUNT （*）和select top 1 语句
 *      使用内层限定原则，在拼写SQL语句时，将查询条件分解、分类，并尽量在SQL语句的最里层进行限定，以减少数据的处理量
 *      应绝对避免在order by子句中使用表达式
 *      小心使用 IN 和 OR，需要注意In集合中的数据量。建议集合中的数据不超过200个
 *      <> 用 < 、 > 代替，>用>=代替， < 用< =代替，这样可以有效的利用索引
 *      在查询时尽量减少对多余数据的读取包括多余的列与多余的行
 *      对于复合索引要注意，例如在建立复合索引时列的顺序是F1，F2，F3，则在where或order by子句中这些字段出现的顺序要与建立索引时的字段顺序一致，且必须包含第一列。只能是F1或F1，F2或F1，F2，F3。否则不会用到该索引
 * 10.数据库去空格的情况？
 *  就是空格、控制符
 *  空格替换掉就行
 *  控制符用ASCII替换或者对应的控制符替换
 * 11.简单叙述一下MYSQL的优化？
 *  尽量把数据库设计的更小的占磁盘空间
 *  尽可能使用更小的整数类型.(mediumint就比int更合适)
 *  尽可能的定义字段为not null,除非这个字段需要null
 *  如果没有用到变长字段的话比如varchar,那就采用固定大小的纪录格式比如char
 *  表的主索引应该尽可能的短，这样的话每条纪录都有名字标志且更高效
 *  只创建确实需要的索引
 *  所有数据都得在保存到数据库前进行处理
 *  所有字段都得有默认值
 *  在某些情况下,把一个频繁扫描的表分成两个速度会快好多
 *  尽量使用长连接
 *  如果两个关联表要做比较话，做比较的字段必须类型和长度都一致
 *  LIMIT语句尽量要跟order by或者 distinct.这样可以避免做一次full table scan
 *  如果想要清空表的所有记录,建议用truncate table table_name而不是delete from table_name
 *  在一条insert语句中采用多重纪录插入格式，而且使用load data infile来导入大量数据，这比单纯的insert快好多
 *  经常OPTIMIZE TABLE 来整理碎片
 *  还有就是date类型的数据，如果频繁要做比较的话尽量保存在unsigned int 类型比较快
 *  并行搜索，把数据分开存放到多个磁盘中，这样能加快搜索时间
 *  数据存放在主内存中
 * 12.说一下数据库的存储过程？
 *  存储过程与函数的区别：
 *      存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强
 *      存储过程来说可以返回参数(output)，而函数只能返回值或者表对象
 *      存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一个部分来调用
 *  存储过程的优点：
 *      执行速度更快
 *      允许模块化程序设计
 *      提高系统安全性
 *      减少网络流通量
 * 13.数据库创建索引的缺点？
 *  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
 *  索引需要占物理空间
 *  当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度
 * 14.关于HQL与SQL？
 *  HQL面向对象，而SQL操纵关系数据库
 *  在 HQL 与 SQL 中，都包含 select,insert,update,delete 语句
 * 15.用Java怎么实现有每天有1亿条记录的DB储存？MySQL上亿记录数据量的数据库如何设计？
 *  这么大数据量首先建议 使用大数据的DB，可以用spring batch 来做类似这样的处理。定量向DB存储数据。如果需要定时，可以考虑 quartz
 *  读写分离
 *  纵向横向拆分库、表
 * 16.Mysql的引擎有哪些？支持事物么？DB储存引擎有哪些？
 *  MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE
 *  MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎
 *  MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎
 *  MEMORY存储引擎提供“内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中
 *  InnoDB和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎
 *  EXAMPLE存储引擎是一个“存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者
 *  NDB Cluster是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows
 *  ARCHIVE存储引擎被用来无索引地，非常小地覆盖存储的大量数据
 *  CSV存储引擎把数据以逗号分隔的格式存储在文本文件中
 *  BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集
 *  FEDERATED存储引擎把数据存在远程数据库中
 * 17.not in与not exists
 *  not exists都比not in要快
 * 18.两个表，需要用一条sql语句完成复制？
 *  insert into a_table select id,name from b_table;
 * 19.什么是基本表，什么是视图，两者的区别和联系是什么？
 *  基本表：基本表的定义指建立基本关系模式，而变更则是指对数据库中已存在的基本表进行删除与修改
 *  视图是已经编译好的sql语句
 *  视图没有实际的物理记录
 *  表是内容，视图是窗口
 *  表只用物理空间而视图不占用物理空间；视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改
 *  表是内模式，视图是外模式
 *  视图是查看数据表的一种方法，视图可以不给用户接触数据表，从而不知道表结构
 *  视图的建立和删除只影响视图本身，不影响对应的基本表
 * 20.什么是事务？什么是锁？
 *  事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制
 *  事务的隔离级别通过锁的机制来实现
 *  在具体的程序设计中，开启事务其实是要数据库支持才行的，如果数据库本身不支持事务，那么仍然无法确保你在程序中使用的事务是有效的
 *  锁可以分为乐观锁和悲观锁：
 *      悲观锁：认为在修改数据库数据的这段时间里存在着也想修改此数据的事务
 *      乐观锁：认为在短暂的时间里不会有事务来修改此数据库的数据
 */















































